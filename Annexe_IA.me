Annexe IA : 

L'utilisation de l'IA générative s'est faite : 
Dans la visulation des diagrammes, nous nous sommes aidés de l'IA qui a généré le code Mermaid d'après nos idées d'implémentation des programmes.

Pour la rédaction du README et de cette annexe : pour la mise en page (syntaxe) des formats.md et pour s'assurer qu'il n'y a pas de fautes d'orthographe. Le texte sinon est resté inchangé.

Dans le code : 
La principale utilisation de l'IA s'est faite pour le débuggage : rajout de multiples print pour vérifier à quelle instruction le programme n'était pas correct, le rajout des flush pour les print, qui "nettoient" les buffers liés à l'écriture... Nous spécifierons cela pour chaque programme afin de rester le plus exhaustif possible.
Nous retrouvons aussi l'utilisation de l'IA pour la suggestion d'API à utiliser : sysv_ipc a été une des recommendations de l'IA, nous lui avons demandé, en complément de la documentation, d'illustrer comment fonctionne la mémoire partagée de l'API, l'utilsation de select dans le displaybonus.py pour avoir un terminal non bloquant.

env.py : 
utilisation surtout pour le débuggage lié à l'utilisation des sockets
Ligne 48 à 64 : rajout de l'IA de la suppression des mutex, de la Mq et de la mémoire partagée au cas où le noettyage du code précédent ne s'est pas bien fait.
l'IA générative nous a donné l'idée d'emploi du module struct, notamment pour faire l'extraction de données aux lignes 102-108
ligne 112 : utilisation de client.sendall au lieu de client.send grâce à l'IA
ligne 144 : conversion en octet de notre if BoolSecheresse else et du header


Dans les code "bonus":
Dans env.py : 
Ligne 113 à 123 : utilisation de l'IA pour résoudre le problème de la taille de la mémoire partagée et pour l'ajout de la vérification de la MQ.
ligne 179 : ajout de sysv_ipc.BusyError comme un except, nous n'étions pas au courant de ce type de gestion d'erreur par sysv_ipc

ligne 196 à 204, dans la boucle : 
l'IA nous a corrigé sur la pousse de l'herbe avec l'utilsation de random.random() et aussi pour les conversions propres des tableaux de bytes en tableaux de int 

ligne 219 : ajout d'un time.sleep (la plupart des time.sleep ont été ajoutés lors du débbugage)

Dans prey : 

ligne 11 à 23 : 
L'IA a généré la plupart des fonctions mathématiques (avoir la droite,gauche,haut,bas dans un tableau linéaire).

ligne 75 : idée de l'IA d'ajouter un seuil de satiété pour que la proie reste en état passif plus longtemps.

lgine 139 et 140 : l'IA nous a donné l'idée de générer les petits tableax danger_proche et safe_cases pour l'heuristique de fuite

ligne 178-179 : ajout de l'IA pour que la proie nettoie bien sa case lorsqu'elle meurt

ligne 213-214 : ajout de l'IA pour vérifier que les proies aient bien la bonne position
